## Developed by: ##

Antonio Tepsich

Vianca MÃ³naco 

Maximo Gubitosi

Romanella Colombini

# Travelling Salesman Problem: Genetic Algorithms #

Genetic algorithms are a search technique based on Darwin's evolutionary theory. In this paper, such heuristics were implemented, using the object-oriented programming paradigm, in order to solve the Travelling Salesman Problem; that problem focuses on finding the optimal route by which a traveller can travel through a series of cities in the shortest possible time or with the shortest possible distance.

### Dependencies ###
* gcc
* Python3
* NumPy
* Matplotlib
* Makefile

## Quick Start ##
```
git clone https://github.com/AntonioTepsich/Travelling-Salesman-Problem.git
```
Now run the code:
```
cd Structure
```
```
make
```

### Development: ###

Initially, the following classes were considered:

- City: contains the coordinates of each city, its id (used to access the correct values of a matrix that will have the distances between the cities).
- Path: the roads.
- Traveler: contains several methods implemented to solve the traveller problem based on a genetic algorithm and the population.

However, in the course of development, we realised that we would need to create more classes for other objects that would also be used:

- Fitness: contains the functions to calculate the fitness of each individual.
- DistanceMatrix: creates a dynamic matrix used to store distances between cities.
- DataGuardian: stores the total fitness data of the generations in order to have the possibility to generate a graph at the end of the programme.

To begin with, two functions were used to create the population dynamically; one of them created a route randomly, while the other created instances of it to be stored in a vector representing the population. However, our goal was to apply classes to address the design of the solution to the problem, so we considered creating another class that creates the population randomly in its constructor. It was decided to implement the program with composition relations between the classes, in this way it would only be enough to create an object, TravelerGeneticAlgorithm, to start executing the code.

Even so, we noticed the need to generalise and abstract the algorithm, so we tried to identify the classes from which (the ones we had already created) could be derived, and also how to create these new structures so that they could be used in the future. The result was the following:


[Class Diagram](https://viewer.diagrams.net/?tags=%7B%7D&highlight=0000ff&edit=_blank&layers=1&nav=1#R7V1rc5s4F%2F41nkk7Ew932x%2FtpM12t33fNEm33U8ZxRCbLUYu4CTur18JJC6SAJFAfAmdTmuEkITORec850gM9LPV00UA1ssv0Ha8gabYTwP9fKBphjlC%2F%2BKCbVIwssZJwSJw7aRIzQqu3d9OUqgrpHTj2k5YqBhB6EXuulg4h77vzKNCGQgC%2BFisdg%2B9Yq9rsHC4gus58PjS764dLZNSTVGU7MYfjrtYRuydFaC1SUG4BDZ8zBXpHwb6WQBhlPxaPZ05Hp48OjHfP22%2Fe59%2FWhd%2Ffg1%2FgW%2Bzv27%2B9%2Fdp0tjHJo%2Bk7xA4fvTspn%2F%2FvP%2F4x9%2FGvz%2FWlx%2B%2FPioX07s%2FT8kjygPwNmTCLhzfidz51FvAwI2WK%2FLu0ZbOaPjorjzgo6vZPfSja3IHTccMeO7CR7%2FnaJxOgAoenAC1BbwpuRHBNSqdL13P%2Fgy2cIPfJozA%2FCe9mi1Rr79Rs8BDt1RUgG4HEeErzSrUuMZPomIFlQZOiOpc0ilS06LPIIxInTn0PLAO3bt4wLjKCgQL15%2FBKIIr2hDc%2BLZjk6uU5vFFFMCfKRvh5yUJQwiIZ8N5yvElIdSFA1dOFGxRFXI35TkidSq9fsx4WB2TsmWefVVSCIjcLNK20%2B6ukJwBf4EmIetPZ%2FozBP1Zov6sYnfAQ4T3QeTM8DSGeYZEP3KvmhXFbNqAZVWOZQeavobrjQciF%2Fq36N5An6J%2FL9Oy9xwTIzpEOYb1nPuolF3DNZi7%2FuJzXOfcyEquyDzgIoievfdiVlm6tu34MStFIAIJt2H%2BWUPXj%2BKJMmfoL5rOM2VoDkw0oDN0rWbX6C%2BuHkRn0EdcB9yYvRzEyo8OZmcB41WKdz3jbYv0rOUzq5zNCgRvSl1DQF2Gdp4bK59ltMp0BCuYNYRdIRLh5iglbzChz09Vjto6T21dQFkP3DneJQxdzG2oLEjqMhTfFVFNTY6o4xZoemV%2Fdb1vK%2FvK%2BD2bnZ5%2BGo2Xp6rKLzMDbXbhRJmInrwTCK3l4Wm5Cwr0t35tYDy3wLYRWZLHlPVTLPezeOHGSj1XTp9AvxbJ%2FzPatkvLLj2wPcEUQaKIrB24QcQlQwojG%2F%2FQp9FmjZWmBVZYLXikyW7GmHb6gLQ1DIq9JsNLy%2BIH3scjJyX%2BXbgWNpIOls5Evlm09L%2FnGs1f0gYQF7i5Jl6PSlfOOrh2PPQ2mGUQuTCJHiDivn0YGbQ3ycA%2B%2Bbb74Nob4ImoUjXW1xh80jDSaj4ty42X8Hx%2BTvPsMrtG6glZDxkR6h74somAVMVvaxvZDZ%2F8e3jCUrXAsHTu8i8gnlLxmp9bN2RXidiSLF3IsVoHmwiGiZGaLUhn0ENCp5%2F7MF6wulLvlqRtqJoVtuGLFm2LU%2B83AXhALBI815tQem%2BiRW9CLVr3hingmFF73oTKeBP6eH%2B9iRHHuqcYtUidiHNk511sQGC74O26EZY0x1W4EUIG68qNmPRuROtEFbkRIqJ250aIXP8jt9x5E0jUrLTl3qUtnBhkrbYuY%2B%2BL7MADfM3mzoPoxTsYXGdzWu91tE1CWeel7X7rfKC2%2B6twpTi%2BOUwnqfHiJXKSRItXd06SqtXbJI5vT3HQC13deRC7IzNURPwVVUkuP7q4YxmHouh9OPbCof6V493Bxw9ZwSwuQDcoeRu7IyHcBHOnnmR4FJUEEzkJgYMxwYdiTK%2FCKbmEsUGQOkBK0SHRFL3YRDJ48lQ%2BhsY0pDMN6TrDLci9XGBYk2kIERVsc9WIbJQOmOtnUojtoR9Ji%2B0GVnhfKENjZR33PgzYouNuKuMCGwjDgCJH2jArjPByx900i2y312HAsUCd4jjg7a8N8CM32hIfABH%2FFokWGqGuJmtoIVqoT3mDPauaLJoFk8xK7etCi%2BHtwvFxpoOgPepw0AeIub5gitH%2F93hAH90ItRQyXUTIWfRu75N7WZSTehRvE5lIddaLoAkRS6ua0ZEhoOk9ONE%2BXVURqCkirNUdPiEibCL8SH8IzXwspqeEkFiaY1pKxWzSAOpXou6oc5EqvJpASTykYmmHo2TCvKU6csejrQdV9mOcyayGOLwS9nPa3pySpZdOaW4l3p8x3mBDgBloiivuyTCvi6op0UmS4N2rD5PqpkMQoKIpmpejPZ1doqMOYW4FykkA2O18yATeE6mB%2FRrnDbx0gnk9BPnqA5vaNpKjk2oAutEwubyddsada7YIItflPIlH%2Bcz0mFIcZzfY7zN8PgoW1OIYRhvor9g5MDnngCbJNEfZ%2BvSYNlE2Jj3Gko0VWBUIweFlx4i5lseE3zRWUS3arefHdAdViNDTkjjl%2FkcIW6KKbshRhQ36tEgWibylA44R7iL2Z07MonbXGaGSjf2ZE2M4UgttmSOmrZbCf9yYrZbDf0Lmo8GlHPNlFrKsZdLH%2F1q0TMZsPE4Q%2F0tzdIt27LPif%2Fu6DVDMrsKNgAvHTwKAt%2BXhP1QHroA49JcHAkSBvjT%2Bpk9TzE1we40c35I6xx%2Boq9YuLzGShMxeZYa%2FbDmmq29v%2FbZK2ImkFuvM%2BhVGYDG0jhcYcRytsFWJDxQU8feSyikaVvvARayhygM7chGV4sYt8nYZFM%2FgXWxt%2BoZZRnVN7fj15GqT92v6YpXNcphZVdblK%2B0TLAEHy1KWj3KPW1tKg4fwhEqjnQRO8aD5zemX%2BJCQHrTbgWlsFE1V6T1tkwr2OBLQjvbZmy0ywnw4oJ0mAmNFcaFDXRQak2T3iJ0mAlL3GbFDNAi2P%2FDDQ31Mr%2F%2FBTQ8VTaUF50%2B0%2Bfhqm79Cdp6LZg8vX%2BeKkLzS%2BwQq2SAB02Ts%2BF3gimNmRXj2noIJu7SwK1RLoGJZPx2DijyirQyHlBcyGWE1TY2GuiMGSbJozJCVs4jFgtE8sflF5ExrzKrkTDoyqoHWwGildxWWS7Tx0DJGijkea7qpUZy3fb1E%2B83NO3HoZM3VHslt0VxVDcZelYZy04pHDOXqPc5Wbx3pjV1mWQC1M4NVL0%2BIz2c2nQFvTtGm5pAQj5%2FkYPdKsCfLBwtDxCF0CHxaWPUem723q5tzjsCuFkPvndnVOo%2B10HSphutYD7u0uo5ZjBUpffrU89axgwJedD7H7zQGiqPAfcq27J27iHf8ufMlLn8TpwpVy%2Fh%2BHk8qHnOPrXVB2J0fUaoLsbUXWCa8oRFbE4duSjSmrOz60B1Epx8aRNds8a4H1CjRdgGTqQabw6Q%2BEydT2dMJuGT9loAyriN6Gke3SJnBIzZIq8hauT1a06aVq%2FZoTQWjCk%2FecO04oY4kzRzo8mZ0hrF0t7wZojzI3iJ9KWFNWcJ2ln1oiFBRnB32yY5jvW9O1mTzBjuUNR7QPMMnDfVQ1C4W6R6KquBUHj%2FFUNTTLZN%2BSvPS8c3trQzcffSwVCrkrcNSHa4VPPLYGwEvJ6ysRukMljJEcCO2AX6cvOPiXGwW%2BT8nR4A4PYNogs3%2Br4s4GRK7po8acTJ2mJilqq0hTtprIU5sR6%2BEOPG5WcXQVG%2FX7kOqkDmS9HtSLXfE4BMVlJIQa85%2BfS%2FYB4Wr4m%2FK5qEqrg5ilWOAsibSjNd0v2Vn66bZQ1ldEHa8cyiLhnc5M7a43hQ3R4oEOHnqComw3DZNJDxsxTcjz9JBiw4FmsfL8h%2FU6u2LXdgXDGw2EsBYmvDTGG%2FBvBDDZhipAp6Hj3i%2FzZ0AMajZm13ytacD1UBmG7iYkLO688TNHhfrgrCi4JiQsN1ZFEJgbGrb%2F09E9cLxGxxggCwF%2Frl3wgNievGujMe9snjzQBu%2FtSyHtMF1HGTI0SKHuWnUIqC1kYmygr59s8SnPBSMBdWgBQShUxnQDUnlEi6gD7w88ia7qa3Z0l8LshFi0voUYxq0gbYZ7KeVtOyUtMYnrKlsW8z2uJbgNoPblJeOuWxo9Y90hNGZfLINz%2BG8iuG2UxYVhfzJvrzOuUccz6gYod4pGrtdWbPGiPlE0mQ8tExOL%2Bmvq5Z4YPUY1FK2dXyQ2zeuDMf6oPNt4xKbwfdBHVpWOTs2VYdjrb6tEo3YmvqxeLhVHXzQBsgVnFoyts6bUURjZvFSrT1QRBYPqFaR7%2FBU0gFZSqrCAC8v0Q18hvJk0omtpCpjXdhR%2BcgUs%2BqBjuwki0cae0VVkje3l5qKB96%2BhXzWCq%2BhGLVkg3AZT6HKai9iu6QXie0yMox9MF5oTv1utuiwugQxBD2SobFi0lktJ2isc6uFR%2F3aZaYnN0rtYPQ7YSXTGpHrjJPwxTZ30fXZSTQ8Lr3SKUNtRM8V64K3dCazxVKUZzKWxjCWwYYjWkvGYTqy9IpknOxx2j68vw%2Bdjviah7u6UZKILRS0jBc0pZKw9641pS6bWpbjcGVU8dHXtj0%2BYzKc5P8wELg0vxvsZ2m6Yfc0%2FFfspty8Ew%2BrXGwnVfV3KUzHDtIMiwJcI7xty6nZVE678Lm0iTFkP6WhDp%2Fpc%2FGNjdizhhvLZOtcPRJ5%2FL33kyNiCQnb93zQZQDxgeAZgQOwXn6BtoNr%2FAc%3D).

Abstracting the algorithm by implementing the abstract classes GeneticAlgorithm, Population, Fitness, Individual and Gen allowed us to provide a general structure that can be implemented in different problems. The identified entities were separated into classes in order to divide the different tasks needed to tackle the problem. In turn, considering that the high level module class GeneticAlgorithm, which implements the heuristics of the genetic algorithm in a general way, works with the low level module classes Population, Individual and Gen, it was decided to abstract also this second group of classes so that, once again, the code can be implemented in a general way.

Once the declarations are complete, we start implementing the algorithm's own functions.

We chose to separate the stages of natural selection into different methods, the TravelerGeneticAlgorithm class interacts with these and assembles the process.

At the beginning, SelectionRepr() is in charge of choosing the individuals to breed based on their fitness: the best are bred with the best, the worst with the worst and we eliminate the half that had the highest fitness (i.e. those with the "longest" route); every a certain number of generations (defined value CRAZY_TIME), the individuals are not bred with the above mentioned strategy, but the cross is random.

When the "parent" individuals are chosen, they are used in the Reproduction() function, which selects genes from both parent individuals to create the offspring. The genes are chosen randomly, a "stretch" of one parent's genome is selected and the other parent is taken into account to obtain the rest of the genes. The stretch chosen from the first individual is at least 20 per cent of its genome in length and a maximum of 80 per cent of its genome in length.


Breeding doubles the number of individuals in the population, a percentage of these individuals are mutated, and finally, the vector is sorted with the different pathways and the worst half is eliminated.

[Sequence Diagram](https://viewer.diagrams.net/?highlight=0000ff&edit=_blank&layers=1&nav=1&title=secuencia.drawio#R5Vtbb9s2FP41BroCMSRRNz86SZt1aLeiydD1qWAk2iZKiwJFJfF%2B%2FUiJupK2FcdyLutDYR5RFPWdy3fOETMBF%2BuHKwbT1RcaIzJxrPhhAi4njhOEofhfCjalwLfcUrBkOC5FdiO4xv8iJbSUNMcxyjoTOaWE47QrjGiSoIh3ZJAxet%2BdtqCk%2B9QULpEmuI4g0aXfccxXpTT0rEb%2BO8LLVfVk21JX1rCarATZCsb0viUCHybgglHKy1%2FrhwtEJHYVLuV9H7dcrTfGUMKH3PAHnn%2FO3QwQwvCfZ%2FDnF%2Bf7zZmtlrmDJFdvrHbLNxUEjOZJjOQq9gSc368wR9cpjOTVe6FzIVvxNVGX4W1GSc7RnEVKmYW0GblimHFGf9V4yglqF4hx9LD1%2FewaNWFtiK4RZxsxRd3g2cqylKUBoIC%2Fb%2FTmhEq2auls5ilzUaayrJdu0BQ%2FFKCPANd9M9jabhdbO%2FBOhy1I8vOPD2wWbT5bafLX9xsHXp3pdgvJkjLMV%2BsJmN8weIcIYlcoQRxH8%2FpSH3%2FhlKn8ma%2FJZ7xABCdidJ4ihsU2ERNXiBJ%2FbWTnIthwKGRMIRxRQmCa4dtiWUtIGIpyluE79A1lpXIKaa1tOaoDgrVDbZqODJrcqja%2Fq7XQ4BCWQWnuzBpJa85%2Bj0gpTnjxXO984l32tEEZX9ElTSBp6%2BOJuO40sMFgz%2FwO2L7uIbYBaxCO5SFAwzolcPPuNw1x%2BYpYMN6c4GUiRLeUc7ousIOMzyWJSuTFQkKGkriS3BIa%2FaqmqRAUHht%2FsfYS7ZqnLAjFHR7XtcQQgVw4ZDdDMICubv0q7bDRLjBrt1ogozmLkLqnp7h6E4frcgCTvFq%2FsS17X5QyOY7tjBWkPB1sMP9K01waEE3%2BZxziBl0ScQxplW1iEWCNpSD%2F9XiD92i4vQ7awUBnOAZjmwuE%2FVi3KCEiMMtw1E1b0QPm%2F7R%2B%2F5CgTi3HVePLB4VyMdi0Bi3tFDJjqDfadxmP99GGroUWzp4B50r2RDKp0%2BcqnfbAIDrZv5Afdhcq6VNbSOgLblrTlLts3%2FDMvOGt%2B%2BrPV%2FtqLLHcwaEkaTRVPeH5hlJ2LeqASMbtd0tRDLAyhIO5XCzhejIk3JT3qi6VFkXCxoo40c%2BX1jiO5e0iYIs4DZsArgchmHOaNaVbGVYuKKHSwhNaEMeWiPGocm3WK9c8QxgJDPZ9DE416kbnVEJpKiTv8oRjeTtfIfmOLZq1CqTEwsIwrZjmAtj4rSosGFBfg1MqbADHtiA%2FhG7HaVQETjdbcYYRqDsWjoExKNE4j5SRv%2FuUxPgOxzkk7yeOeIjVEujmLsnvWg0bXD80UpMnELSQPpKlMMLJ8nMxunTM1Vw3CxKws01N3nLwo8XPxYWp5VVMXjK7E4JjMXu7%2BttlpodkAK7ZkJ5M7UHXAPtZ8BZqfzwjz4zP2c7IvfndbvE4jBy%2B0iDid4t9YA8LIqMF45mG45ecFyxpaOe8mAhxqE%2BHg%2FX1ZF%2Ftdh6cfhV1JF91LPNzRvW9ykCHGU3LJLa2Aw2mUCv%2FzJpKNNsWMLUttxI0RFCMNu3R4UXe3t6gbzablhuHxyro%2BhFjNg1mrX%2FD2oXaul4VUpp1uwttqe%2BOZkSOZkRF3l7UT1XmDqUppSjCC1H5C0UhJjNv%2BV3VseiiSu19IgPMLRO%2FlrxQsw%2FX8gNXcpulRfRvZf5Fyr%2BmsVhSBJr9KX8%2Fke%2Bl7b0ot7Ue0BlogQnppfvGGqAbE4%2FAQR4Y8DXTMbbdRiIh29CEBvMmWdXU9OL7ok9SUGA%2FZ1%2FUrCFD57qvlBM1RvdAu8PAhnZG7YGVXTga2nppNy7BWn7QJVgQhqcj2B0WdwqG9UCPCYPZNDywa%2Br3YqvXT9xHZlVHT8122cvLrYv8Z66L6q9ZDZDX4nU4TJqu7xsskCo8T18hgX6fbKQKqXrOqBVS5XWv3Q3d525POPqXl7%2FTGHL0KVnQN%2BmAzrM54IlaFOAULQpHryhKu7mhHJKPmCcoy0bIpUQq5fVSqSA8qFfRaoLb3SZ4UI%2BP%2F3n7RB2Naa%2FCcZ3Z1AkHmZ%2Bevtmzqee3GiLdlYE1dUHrqjsoH3uskYPQ7T9256Zda%2Bf8kZzCePzoEnJ4lUMWY3isA0h7DhsfWofTnMsnXdTn8UerwPvqNKWjpjPJ4x2WcV7OyaQnIevaPf8ceAzJGw1YvdbmeUpQ3UQkZV8v4pR1ZeW5gVqmWo8X%2B%2FuRpsWuUPK%2Bv1R39DSmoilK5J5htqr%2FJkBcbp2tPZwilGoFM3X7KHWP96mE4XcLdK%2By%2FcdSRbhnnS1k0KxTTaSLRYbGKeD1D5vzOP5LqBgSIoykSl3o3c8lSn4usOGg0YFJzIvKEfxemJi508A%2BTOuuHfTW8gap%2FWiHx%2FSezBXi4ySiL0mHoOe2rnekT1Wu507DYacRj6bDAYdVVXKk06bhS8%2FQz0aqJr2RH8Yuz2ytSgWN5JsiS1CwOhdZXZNPEXiLyFea4fKI4iUr55oaDyJNEAmWeAmIC4tBMOP3KCsID7Oy8yXEQnfy%2FY6SbHm%2B2U7aJmnKtR6dEYhh80eRpWk0f1kKPvwH).

The process is repeated until the requested number of generations is met or the threshold of change from one generation to the next is sufficiently small.
